'''
Simulations of optogenetics experiments

Note that these are deterministic simulations that need some more 
work to become statistical models

These models are also orthogonal in that they can only consider 
sound angle in one coordinate system but not both.

Stephen Town - 13 Dec 2020
'''

import math
import os, sys

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

sys.path.insert(0, os.path.abspath( os.path.join(os.path.dirname(__file__), '../Analysis')))
import cf_behavior as cf


def softmax(z, beta=1, idx=None):
    """
    Turn an input vector into a probability distribution

    Parameters:
    ----------
    z : list or numpy array
        Input vector (e.g. activations)
    beta : float, optional
        Inverse temperature (coldness)
    idx : logical array or int, optional
        Index of z for specific value to report

    Notes:
        By default (idx=None), probability values will be returned for all
        values of z

        Tip: If you want to maintain scale between z and p (e.g. [1, 2] -> [1/3 2/3])
        set coldness to 1/sqrt(2) (e.g. 2 ** -0.5)

    >>> softmax([1, 2], beta=0)
    [0.5, 0.5]

    Returns:
    --------
    p : float, list or numpy array
        Probabilities of values in z
    """    

    z = [math.exp(zi*beta) for zi in z]    

    if idx is None:
        p = [(zi / sum(z))  for zi in z]
    else:
        p = z[idx] / sum(z)

    return p


def choose(p, n, rng=None):
    """
    Draw events from a multinomial probability distribution

    This function is essentially a wrapper for np.random.Generator.multinomial()
    
    Parameters:
    ----------
    p : list or numpy array
        Probabilities of making one of several actions
    n : int
        Number of draws to make
    rng : numpy random number generator, optional
        Generator object to pass through experiment (or create if not initialized: None)

    Notes:
    ------
    This is an expansion of the binomial case, which is most relevant for the two-choice
    task being studied here; however the multinomial task should enable the code to work
    for tasks with a larger number of responses.
    
    This function is an expansion of the matlab function 'choose' that was inherited from
    the 10 principles for modelling paper. However the python/numpy implementation should
    be more efficient as responses can be drawn for many trials at once.

    Returns:
    --------
    aCount : numpy array
        Counts of instances of each action
    rng : numpy random number generator, optional
        Generator object to pass through rest of simulation
    """

    if rng is None:
        rng = np.random.default_rng()
        print('Creating random number generator"""  """')

    aCount = rng.multinomial(n, p)

    return aCount, rng


def create_stimuli():
    """
    Generate a dataframe with all combinations of speaker location and 
    platform angle
    
    Parameters:
    ----------
    None
    
    Returns:
    --------
    df : pandas dataframe
        Dataframe containing created data
    """

    # Generate combinations of speaker and platform angle
    rows = []
    for speaker in range(1, 13):
        for platform_angle in range(-150, 210, 30):
            rows.append([speaker, platform_angle, 3])  # 3 here is dummy response variable to make compatible with cf_behavior function

    # Create data frame
    var_names = ['Speaker Location', 'CenterSpoutRotation', 'Response']
    df = pd.DataFrame(rows, columns=var_names)

    df = cf.format_angular_values(df)

    # Ignore dummy response
    vars2drop = ['Response', 'response_angle_world', 'response_angle_platform']
    df.drop(columns=vars2drop, inplace=True)

    return df


def load_config(file_path):
    """
    Load configuration used to run simulation
    
    Parameters:
    ----------
    file_path : pathlib object
        Directory containing simulation results (as generated by, for example, TestModel_CF8_FullAllo_Theta.m)
    
    Returns:
    --------
    config : Dict
        Dictionary containing configuration info
    """

    config = pd.read_csv( file_path / 'config.txt', sep='\t', header=None)
    cDict = config.set_index(0).to_dict()
    config = cDict[1]

    for (key, value) in config.items():
        if key in ['nFolds','nParams','nRuns','nSim','include_probe_data']:
            config[key] = int(float(value))
        
    return config


def run_world_centred_mdl(ax, df, decision_var, add_noise=True):

    df['response_P'] = run_mdl(df[decision_var], [0.5, np.radians(0), 0.5], add_noise=add_noise)

    draw_pivot_table(ax, df, 'speaker_angle_world', 'speaker_angle_platform')


def run_head_centred_mdl(ax, df, decision_var, add_noise=True):

    df['response_P'] = run_mdl(df[decision_var], [0.5, np.radians(-90), 0.475], add_noise=add_noise)

    draw_pivot_table(ax, df, 'speaker_angle_world', 'speaker_angle_platform')


def run_mdl(theta, coefs):
    """
    Apply model (using coeficients) to predictor values (theta)
    
    Parameters:
    ----------
    theta : pandas series
        Sound angles in coordinate frame relevant for model
    coefs : dictionary (preferred) or list (legacy)
        Three-element array containing model coefficients 
        (horizontal shift, vertical shift and amplitude)

    TO DO:
    Maybe merge this back into simulations as much of this functionality
    has been overtaken by use of softmax

    Alternatively, convert coefs into a model object that contains a 
    labelled predictor (which is also a column in df, where df would replace theta)
    df.columns => ['speaker_angle_world','speaker_angle_platform'... etc.]
    mdl = dict(predictor='speaker_angle_world', etc.)
    e.g. run_mdl(df, mdl)
    
    
    Returns:
    --------
    z : pandas series
        Series containing activation values for going to spout 9 (West / Left)
    """

    if isinstance(coefs, list):                                             # This is legacy and will be removed in future
        
        theta = np.radians(theta)           
        coefs[1] = np.radians(coefs[1])         # Convert to radians for python implementation      
        
        
        z = coefs[0] + (np.cos((theta - coefs[1])) * coefs[2])


    if isinstance(coefs, dict):
        
        theta = np.radians(theta)           # Convert to radians for python implementation
        coefs['horiz_offset'] = np.radians(coefs['horiz_offset'])
        
        z = coefs['vert_offset'] + (np.cos(theta - coefs['horiz_offset']) * coefs['amplitude'])

    return z


def run_matlab_mdl(theta, coefs):
    """
    Apply model as transfer function using labelled parameters

    TO DO: Merge with run_mdl
    
    Parameters:
    ----------
    theta : pandas series
        Sound angles in coordinate frame relevant for model, in degrees
    coefs : dict or pandas dataframe
        Object with labelled coefficients
    
    Returns:
    --------
    p_resp : pandas series
        Series containing response probabilities
    """

    if coefs.shape[0] > 1:
        print("Warning: Multiple models converge on same NLL - taking first model in list")
        coefs = coefs.iloc[0].to_dict()
        p_resp = coefs['vert_offset'] + (np.cos(np.radians(theta - coefs['horiz_offset'])) * coefs['amplitude'])
    
    if isinstance(coefs, pd.DataFrame):
        p_resp = coefs['vert_offset'].to_numpy() + (np.cos(np.radians(theta - coefs['horiz_offset'].to_numpy())) * coefs['amplitude'].to_numpy())

    return p_resp


def draw_pivot_table(ax, df, row_var, col_var):
    """
    Draw joint plot of response probabilities as a heatmap
    
    Parameters:
    ----------
    ax : matplotlib axes
        Axes to plot on
    df : pandas dataframe
        Dataframe containing response probabilities for each combination of 
        sound angle in head and world-centered coordinates
    row_var : str
        Name of column to use as the y axis (e.g. 'speaker_angle_world')
    col_var : str
        Name of column to use as the x axis (e.g. 'speaker_angle_platform')
    
    Notes:
    ------
    This function will wrap data at ±180°
    
    Returns:
    --------
    None
    """

    # Wrap to have both ±180°
    extra_f = df[df['speaker_angle_world'] == -180]
    extra_f.loc[:, 'speaker_angle_world'] = 180
    
    df = pd.concat([df, extra_f])

    extra_g = df[df['speaker_angle_platform'] == -180]
    extra_g.loc[:, 'speaker_angle_platform'] = 180
        
    df = pd.concat([df, extra_g])

    
    piv = pd.pivot_table(df, values='response_P', index=[row_var], columns=[col_var])

    ax = sns.heatmap(piv, ax=ax, square=True, cmap='vlag', vmin=0, vmax=1, cbar=False)

    ax.set_xticks([0.5, 6.5, 12.5])
    ax.set_yticks([0.5, 6.5, 12.5])
    ax.set_xticklabels(['-180', '0', '180'], fontsize=8)
    ax.set_yticklabels(['-180', '0', '180'], fontsize=8)
    ax.invert_yaxis()

    plt.setp(ax.xaxis.get_majorticklabels(), rotation=45)

    ax.hlines(6.5, 0, 13, linestyle='dashed', linewidth=1, color="#3d3d3d")
    ax.vlines(6.5, 0, 13, linestyle='dashed', linewidth=1, color="#3d3d3d")

    ax.vlines([0, 13], 0, 13, linewidth=1, color="k")
    ax.hlines([0, 13], 0, 13, linewidth=1, color="k")

    return None


def get_percent_correct(df, coldness=1, task_var='speaker_angle_world', task_map=None, nIterations=1000, generator=None):
    """
    Description
    
    Parameters:
    ----------
    df : pandas dataframe
        Dataframe giving speaker locations and response probabilities for a specific model
    task_map : pandas dataframe
        Dataframe giving the speaker location and correct response location 
        using angular notation, as well as whether logical value indicating
        how increasing response probabilities should be treated (respP = 1 == always True)
    
    Returns:
    --------
    results : pandas dataframe
        Results dataframe containing number of trials correct
    """

    if task_map is None:
        task_map = pd.DataFrame([[-180, 3, 0],[0, 9, 1]], columns=[task_var,'Response','Binary'])

    # Filter for test stimuli
    test_locations = task_map[task_var].unique()
    df = df[df[task_var].isin(test_locations)]

    results = []

    # For each stimulus
    for platform, pData in df.groupby(by='CenterSpoutRotation'):      

        nTrials, nCorrect = 0, 0      

        for _, row in pData.iterrows():
            
            z = [1-row['response_activation'], row['response_activation']]    # Note here that the "1-x" could be problematic but I don't know what else would be appropriate
            p = softmax(z, beta=coldness)           

            response_count, generator = choose(p, n=nIterations, rng=generator)

            idx = task_map[ task_map[task_var] == row[task_var]]['Binary'].to_numpy()

            nCorrect += response_count[idx]
            nTrials += nIterations
            
        results.append(
            dict(
                CenterSpoutRotation = platform,
                nCorrect = nCorrect,
                nTrials = nTrials   
            ))    

    results = pd.DataFrame(results)
    results['pCorrect'] = results['nCorrect'] / results['nTrials'] * 100
    
    return results, generator


def get_response_probability(df, coldness=1, nIterations=1000, generator=None):
    """
    Description
    
    Parameters:
    ----------
    df : pandas dataframe
        Dataframe giving speaker locations and response probabilities for a specific model
    
    Returns:
    --------
    results : pandas dataframe
        Results dataframe with response proportions added
    """

    def sim_trial(activation, generator=None):

        z = [1-activation, activation]    # Note here that the "1-x" could be problematic but I don't know what else would be appropriate
        p = softmax(z, beta=coldness)           

        response_count, generator = choose(p, n=nIterations, rng=generator)
        p_response = response_count[1] / nIterations
        
        return p_response

    
    df['response_P'] = df['response_activation'].apply(sim_trial, **dict(generator=generator))
    
    return df, generator

        
def main():
    return None

    
if __name__ == "__main__":
    main()
    